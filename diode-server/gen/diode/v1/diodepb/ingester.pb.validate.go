// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: diode/v1/ingester.proto

package diodepb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _ingester_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Device with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Device) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Device with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DeviceMultiError, or nil if none found.
func (m *Device) ValidateAll() error {
	return m.validate(true)
}

func (m *Device) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) > 64 {
		err := DeviceValidationError{
			field:  "Name",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDeviceType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "DeviceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "DeviceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeviceType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "DeviceType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlatform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlatform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "Platform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSite()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSite()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "Site",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _Device_Status_InLookup[m.GetStatus()]; !ok {
		err := DeviceValidationError{
			field:  "Status",
			reason: "value must be in list [offline active planned staged failed inventory decommissioning]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPrimaryIp4()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "PrimaryIp4",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "PrimaryIp4",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryIp4()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "PrimaryIp4",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimaryIp6()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "PrimaryIp6",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceValidationError{
					field:  "PrimaryIp6",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryIp6()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceValidationError{
				field:  "PrimaryIp6",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.DeviceFqdn != nil {

		if l := utf8.RuneCountInString(m.GetDeviceFqdn()); l < 1 || l > 255 {
			err := DeviceValidationError{
				field:  "DeviceFqdn",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Serial != nil {

		if utf8.RuneCountInString(m.GetSerial()) > 50 {
			err := DeviceValidationError{
				field:  "Serial",
				reason: "value length must be at most 50 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.AssetTag != nil {

		if utf8.RuneCountInString(m.GetAssetTag()) > 200 {
			err := DeviceValidationError{
				field:  "AssetTag",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := DeviceValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if len(errors) > 0 {
		return DeviceMultiError(errors)
	}

	return nil
}

// DeviceMultiError is an error wrapping multiple validation errors returned by
// Device.ValidateAll() if the designated constraints aren't met.
type DeviceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceMultiError) AllErrors() []error { return m }

// DeviceValidationError is the validation error returned by Device.Validate if
// the designated constraints aren't met.
type DeviceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceValidationError) ErrorName() string { return "DeviceValidationError" }

// Error satisfies the builtin error interface
func (e DeviceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDevice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceValidationError{}

var _Device_Status_InLookup = map[string]struct{}{
	"offline":         {},
	"active":          {},
	"planned":         {},
	"staged":          {},
	"failed":          {},
	"inventory":       {},
	"decommissioning": {},
}

// Validate checks the field values on Interface with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Interface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Interface with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InterfaceMultiError, or nil
// if none found.
func (m *Interface) ValidateAll() error {
	return m.validate(true)
}

func (m *Interface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDevice() == nil {
		err := InterfaceValidationError{
			field:  "Device",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetDevice(); a != nil {

	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := InterfaceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Interface_Type_InLookup[m.GetType()]; !ok {
		err := InterfaceValidationError{
			field:  "Type",
			reason: "value must be in list [virtual bridge lag 100base-fx 100base-lfx 100base-tx 100base-t1 1000base-t 1000base-x-gbic 1000base-x-sfp 2.5gbase-t 5gbase-t 10gbase-t 10gbase-cx4 10gbase-x-sfpp 10gbase-x-xfp 10gbase-x-xenpak 10gbase-x-x2 25gbase-x-sfp28 50gbase-x-sfp56 40gbase-x-qsfpp 50gbase-x-sfp28 100gbase-x-cfp 100gbase-x-cfp2 100gbase-x-cfp4 100gbase-x-cxp 100gbase-x-cpak 100gbase-x-dsfp 100gbase-x-sfpdd 100gbase-x-qsfp28 100gbase-x-qsfpdd 200gbase-x-cfp2 200gbase-x-qsfp56 200gbase-x-qsfpdd 400gbase-x-cfp2 400gbase-x-qsfp112 400gbase-x-qsfpdd 400gbase-x-osfp 400gbase-x-osfp-rhs 400gbase-x-cdfp 400gbase-x-cfp8 800gbase-x-qsfpdd 800gbase-x-osfp 1000base-kx 10gbase-kr 10gbase-kx4 25gbase-kr 40gbase-kr4 50gbase-kr 100gbase-kp4 100gbase-kr2 100gbase-kr4 ieee802.11a ieee802.11g ieee802.11n ieee802.11ac ieee802.11ad ieee802.11ax ieee802.11ay ieee802.15.1 other-wireless gsm cdma lte sonet-oc3 sonet-oc12 sonet-oc48 sonet-oc192 sonet-oc768 sonet-oc1920 sonet-oc3840 1gfc-sfp 2gfc-sfp 4gfc-sfp 8gfc-sfpp 16gfc-sfpp 32gfc-sfp28 64gfc-qsfpp 128gfc-qsfp28 infiniband-sdr infiniband-ddr infiniband-qdr infiniband-fdr10 infiniband-fdr infiniband-edr infiniband-hdr infiniband-ndr infiniband-xdr t1 e1 t3 e3 xdsl docsis gpon xg-pon xgs-pon ng-pon2 epon 10g-epon cisco-stackwise cisco-stackwise-plus cisco-flexstack cisco-flexstack-plus cisco-stackwise-80 cisco-stackwise-160 cisco-stackwise-320 cisco-stackwise-480 cisco-stackwise-1t juniper-vcp extreme-summitstack extreme-summitstack-128 extreme-summitstack-256 extreme-summitstack-512 other]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Interface_Mode_InLookup[m.GetMode()]; !ok {
		err := InterfaceValidationError{
			field:  "Mode",
			reason: "value must be in list [access tagged tagged-all]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Label != nil {

		if l := utf8.RuneCountInString(m.GetLabel()); l < 1 || l > 64 {
			err := InterfaceValidationError{
				field:  "Label",
				reason: "value length must be between 1 and 64 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Mtu != nil {

		if val := m.GetMtu(); val < 1 || val > 65536 {
			err := InterfaceValidationError{
				field:  "Mtu",
				reason: "value must be inside range [1, 65536]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MacAddress != nil {
		// no validation rules for MacAddress
	}

	if m.Speed != nil {

		if m.GetSpeed() < 0 {
			err := InterfaceValidationError{
				field:  "Speed",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Wwn != nil {
		// no validation rules for Wwn
	}

	if m.MgmtOnly != nil {
		// no validation rules for MgmtOnly
	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := InterfaceValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MarkConnected != nil {
		// no validation rules for MarkConnected
	}

	if len(errors) > 0 {
		return InterfaceMultiError(errors)
	}

	return nil
}

// InterfaceMultiError is an error wrapping multiple validation errors returned
// by Interface.ValidateAll() if the designated constraints aren't met.
type InterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfaceMultiError) AllErrors() []error { return m }

// InterfaceValidationError is the validation error returned by
// Interface.Validate if the designated constraints aren't met.
type InterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfaceValidationError) ErrorName() string { return "InterfaceValidationError" }

// Error satisfies the builtin error interface
func (e InterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfaceValidationError{}

var _Interface_Type_InLookup = map[string]struct{}{
	"virtual":                 {},
	"bridge":                  {},
	"lag":                     {},
	"100base-fx":              {},
	"100base-lfx":             {},
	"100base-tx":              {},
	"100base-t1":              {},
	"1000base-t":              {},
	"1000base-x-gbic":         {},
	"1000base-x-sfp":          {},
	"2.5gbase-t":              {},
	"5gbase-t":                {},
	"10gbase-t":               {},
	"10gbase-cx4":             {},
	"10gbase-x-sfpp":          {},
	"10gbase-x-xfp":           {},
	"10gbase-x-xenpak":        {},
	"10gbase-x-x2":            {},
	"25gbase-x-sfp28":         {},
	"50gbase-x-sfp56":         {},
	"40gbase-x-qsfpp":         {},
	"50gbase-x-sfp28":         {},
	"100gbase-x-cfp":          {},
	"100gbase-x-cfp2":         {},
	"100gbase-x-cfp4":         {},
	"100gbase-x-cxp":          {},
	"100gbase-x-cpak":         {},
	"100gbase-x-dsfp":         {},
	"100gbase-x-sfpdd":        {},
	"100gbase-x-qsfp28":       {},
	"100gbase-x-qsfpdd":       {},
	"200gbase-x-cfp2":         {},
	"200gbase-x-qsfp56":       {},
	"200gbase-x-qsfpdd":       {},
	"400gbase-x-cfp2":         {},
	"400gbase-x-qsfp112":      {},
	"400gbase-x-qsfpdd":       {},
	"400gbase-x-osfp":         {},
	"400gbase-x-osfp-rhs":     {},
	"400gbase-x-cdfp":         {},
	"400gbase-x-cfp8":         {},
	"800gbase-x-qsfpdd":       {},
	"800gbase-x-osfp":         {},
	"1000base-kx":             {},
	"10gbase-kr":              {},
	"10gbase-kx4":             {},
	"25gbase-kr":              {},
	"40gbase-kr4":             {},
	"50gbase-kr":              {},
	"100gbase-kp4":            {},
	"100gbase-kr2":            {},
	"100gbase-kr4":            {},
	"ieee802.11a":             {},
	"ieee802.11g":             {},
	"ieee802.11n":             {},
	"ieee802.11ac":            {},
	"ieee802.11ad":            {},
	"ieee802.11ax":            {},
	"ieee802.11ay":            {},
	"ieee802.15.1":            {},
	"other-wireless":          {},
	"gsm":                     {},
	"cdma":                    {},
	"lte":                     {},
	"sonet-oc3":               {},
	"sonet-oc12":              {},
	"sonet-oc48":              {},
	"sonet-oc192":             {},
	"sonet-oc768":             {},
	"sonet-oc1920":            {},
	"sonet-oc3840":            {},
	"1gfc-sfp":                {},
	"2gfc-sfp":                {},
	"4gfc-sfp":                {},
	"8gfc-sfpp":               {},
	"16gfc-sfpp":              {},
	"32gfc-sfp28":             {},
	"64gfc-qsfpp":             {},
	"128gfc-qsfp28":           {},
	"infiniband-sdr":          {},
	"infiniband-ddr":          {},
	"infiniband-qdr":          {},
	"infiniband-fdr10":        {},
	"infiniband-fdr":          {},
	"infiniband-edr":          {},
	"infiniband-hdr":          {},
	"infiniband-ndr":          {},
	"infiniband-xdr":          {},
	"t1":                      {},
	"e1":                      {},
	"t3":                      {},
	"e3":                      {},
	"xdsl":                    {},
	"docsis":                  {},
	"gpon":                    {},
	"xg-pon":                  {},
	"xgs-pon":                 {},
	"ng-pon2":                 {},
	"epon":                    {},
	"10g-epon":                {},
	"cisco-stackwise":         {},
	"cisco-stackwise-plus":    {},
	"cisco-flexstack":         {},
	"cisco-flexstack-plus":    {},
	"cisco-stackwise-80":      {},
	"cisco-stackwise-160":     {},
	"cisco-stackwise-320":     {},
	"cisco-stackwise-480":     {},
	"cisco-stackwise-1t":      {},
	"juniper-vcp":             {},
	"extreme-summitstack":     {},
	"extreme-summitstack-128": {},
	"extreme-summitstack-256": {},
	"extreme-summitstack-512": {},
	"other":                   {},
}

var _Interface_Mode_InLookup = map[string]struct{}{
	"access":     {},
	"tagged":     {},
	"tagged-all": {},
}

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := ClusterValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSite()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSite()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "Site",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _Cluster_Status_InLookup[m.GetStatus()]; !ok {
		err := ClusterValidationError{
			field:  "Status",
			reason: "value must be in list [offline active planned staged failed decommissioning]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := ClusterValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

var _Cluster_Status_InLookup = map[string]struct{}{
	"offline":         {},
	"active":          {},
	"planned":         {},
	"staged":          {},
	"failed":          {},
	"decommissioning": {},
}

// Validate checks the field values on ClusterType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterTypeMultiError, or
// nil if none found.
func (m *ClusterType) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := ClusterTypeValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := ClusterTypeValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ClusterType_Slug_Pattern.MatchString(m.GetSlug()) {
		err := ClusterTypeValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterTypeValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterTypeValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterTypeValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := ClusterTypeValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ClusterTypeMultiError(errors)
	}

	return nil
}

// ClusterTypeMultiError is an error wrapping multiple validation errors
// returned by ClusterType.ValidateAll() if the designated constraints aren't met.
type ClusterTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterTypeMultiError) AllErrors() []error { return m }

// ClusterTypeValidationError is the validation error returned by
// ClusterType.Validate if the designated constraints aren't met.
type ClusterTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterTypeValidationError) ErrorName() string { return "ClusterTypeValidationError" }

// Error satisfies the builtin error interface
func (e ClusterTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterTypeValidationError{}

var _ClusterType_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

// Validate checks the field values on ClusterGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterGroupMultiError, or
// nil if none found.
func (m *ClusterGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := ClusterGroupValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := ClusterGroupValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ClusterGroup_Slug_Pattern.MatchString(m.GetSlug()) {
		err := ClusterGroupValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterGroupValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterGroupValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterGroupValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := ClusterGroupValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ClusterGroupMultiError(errors)
	}

	return nil
}

// ClusterGroupMultiError is an error wrapping multiple validation errors
// returned by ClusterGroup.ValidateAll() if the designated constraints aren't met.
type ClusterGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterGroupMultiError) AllErrors() []error { return m }

// ClusterGroupValidationError is the validation error returned by
// ClusterGroup.Validate if the designated constraints aren't met.
type ClusterGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterGroupValidationError) ErrorName() string { return "ClusterGroupValidationError" }

// Error satisfies the builtin error interface
func (e ClusterGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterGroupValidationError{}

var _ClusterGroup_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

// Validate checks the field values on VirtualMachine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VirtualMachine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualMachine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VirtualMachineMultiError,
// or nil if none found.
func (m *VirtualMachine) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualMachine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) > 64 {
		err := VirtualMachineValidationError{
			field:  "Name",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _VirtualMachine_Status_InLookup[m.GetStatus()]; !ok {
		err := VirtualMachineValidationError{
			field:  "Status",
			reason: "value must be in list [offline active planned staged failed decommissioning]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSite()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSite()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Site",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDevice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDevice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Device",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlatform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlatform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "Platform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimaryIp4()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "PrimaryIp4",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "PrimaryIp4",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryIp4()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "PrimaryIp4",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimaryIp6()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "PrimaryIp6",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualMachineValidationError{
					field:  "PrimaryIp6",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryIp6()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualMachineValidationError{
				field:  "PrimaryIp6",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VirtualMachineValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VirtualMachineValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VirtualMachineValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Vcpus != nil {

		if m.GetVcpus() < 0 {
			err := VirtualMachineValidationError{
				field:  "Vcpus",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Memory != nil {

		if m.GetMemory() < 0 {
			err := VirtualMachineValidationError{
				field:  "Memory",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Disk != nil {

		if m.GetDisk() < 0 {
			err := VirtualMachineValidationError{
				field:  "Disk",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := VirtualMachineValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if len(errors) > 0 {
		return VirtualMachineMultiError(errors)
	}

	return nil
}

// VirtualMachineMultiError is an error wrapping multiple validation errors
// returned by VirtualMachine.ValidateAll() if the designated constraints
// aren't met.
type VirtualMachineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualMachineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualMachineMultiError) AllErrors() []error { return m }

// VirtualMachineValidationError is the validation error returned by
// VirtualMachine.Validate if the designated constraints aren't met.
type VirtualMachineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualMachineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualMachineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualMachineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualMachineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualMachineValidationError) ErrorName() string { return "VirtualMachineValidationError" }

// Error satisfies the builtin error interface
func (e VirtualMachineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualMachine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualMachineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualMachineValidationError{}

var _VirtualMachine_Status_InLookup = map[string]struct{}{
	"offline":         {},
	"active":          {},
	"planned":         {},
	"staged":          {},
	"failed":          {},
	"decommissioning": {},
}

// Validate checks the field values on VMInterface with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VMInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VMInterface with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VMInterfaceMultiError, or
// nil if none found.
func (m *VMInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *VMInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetVirtualMachine() == nil {
		err := VMInterfaceValidationError{
			field:  "VirtualMachine",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetVirtualMachine(); a != nil {

	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := VMInterfaceValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VMInterfaceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VMInterfaceValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VMInterfaceValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if m.Mtu != nil {

		if val := m.GetMtu(); val < 1 || val > 65536 {
			err := VMInterfaceValidationError{
				field:  "Mtu",
				reason: "value must be inside range [1, 65536]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MacAddress != nil {
		// no validation rules for MacAddress
	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := VMInterfaceValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return VMInterfaceMultiError(errors)
	}

	return nil
}

// VMInterfaceMultiError is an error wrapping multiple validation errors
// returned by VMInterface.ValidateAll() if the designated constraints aren't met.
type VMInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VMInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VMInterfaceMultiError) AllErrors() []error { return m }

// VMInterfaceValidationError is the validation error returned by
// VMInterface.Validate if the designated constraints aren't met.
type VMInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VMInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VMInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VMInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VMInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VMInterfaceValidationError) ErrorName() string { return "VMInterfaceValidationError" }

// Error satisfies the builtin error interface
func (e VMInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVMInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VMInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VMInterfaceValidationError{}

// Validate checks the field values on VirtualDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VirtualDisk) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualDisk with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VirtualDiskMultiError, or
// nil if none found.
func (m *VirtualDisk) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualDisk) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetVirtualMachine() == nil {
		err := VirtualDiskValidationError{
			field:  "VirtualMachine",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if a := m.GetVirtualMachine(); a != nil {

	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := VirtualDiskValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSize() < 0 {
		err := VirtualDiskValidationError{
			field:  "Size",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VirtualDiskValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VirtualDiskValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VirtualDiskValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := VirtualDiskValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return VirtualDiskMultiError(errors)
	}

	return nil
}

// VirtualDiskMultiError is an error wrapping multiple validation errors
// returned by VirtualDisk.ValidateAll() if the designated constraints aren't met.
type VirtualDiskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualDiskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualDiskMultiError) AllErrors() []error { return m }

// VirtualDiskValidationError is the validation error returned by
// VirtualDisk.Validate if the designated constraints aren't met.
type VirtualDiskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualDiskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualDiskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualDiskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualDiskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualDiskValidationError) ErrorName() string { return "VirtualDiskValidationError" }

// Error satisfies the builtin error interface
func (e VirtualDiskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualDisk.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualDiskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualDiskValidationError{}

// Validate checks the field values on IPAddress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IPAddressMultiError, or nil
// if none found.
func (m *IPAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *IPAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetAddress()); ip == nil {
		err := IPAddressValidationError{
			field:  "Address",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _IPAddress_Status_InLookup[m.GetStatus()]; !ok {
		err := IPAddressValidationError{
			field:  "Status",
			reason: "value must be in list [active reserved deprecated dhcp slaac]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _IPAddress_Role_InLookup[m.GetRole()]; !ok {
		err := IPAddressValidationError{
			field:  "Role",
			reason: "value must be in list [loopback secondary anycast vip vrrp hsrp glbp carp]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPAddressValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPAddressValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPAddressValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.AssignedObject.(type) {
	case *IPAddress_Interface:
		if v == nil {
			err := IPAddressValidationError{
				field:  "AssignedObject",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInterface()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPAddressValidationError{
						field:  "Interface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPAddressValidationError{
						field:  "Interface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInterface()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPAddressValidationError{
					field:  "Interface",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.DnsName != nil {

		if utf8.RuneCountInString(m.GetDnsName()) > 255 {
			err := IPAddressValidationError{
				field:  "DnsName",
				reason: "value length must be at most 255 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_IPAddress_DnsName_Pattern.MatchString(m.GetDnsName()) {
			err := IPAddressValidationError{
				field:  "DnsName",
				reason: "value does not match regex pattern \"^([0-9A-Za-z_-]+|\\\\*)(\\\\.[0-9A-Za-z_-]+)*\\\\.?$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := IPAddressValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if len(errors) > 0 {
		return IPAddressMultiError(errors)
	}

	return nil
}

// IPAddressMultiError is an error wrapping multiple validation errors returned
// by IPAddress.ValidateAll() if the designated constraints aren't met.
type IPAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPAddressMultiError) AllErrors() []error { return m }

// IPAddressValidationError is the validation error returned by
// IPAddress.Validate if the designated constraints aren't met.
type IPAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPAddressValidationError) ErrorName() string { return "IPAddressValidationError" }

// Error satisfies the builtin error interface
func (e IPAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPAddressValidationError{}

var _IPAddress_Status_InLookup = map[string]struct{}{
	"active":     {},
	"reserved":   {},
	"deprecated": {},
	"dhcp":       {},
	"slaac":      {},
}

var _IPAddress_Role_InLookup = map[string]struct{}{
	"loopback":  {},
	"secondary": {},
	"anycast":   {},
	"vip":       {},
	"vrrp":      {},
	"hsrp":      {},
	"glbp":      {},
	"carp":      {},
}

var _IPAddress_DnsName_Pattern = regexp.MustCompile("^([0-9A-Za-z_-]+|\\*)(\\.[0-9A-Za-z_-]+)*\\.?$")

// Validate checks the field values on DeviceType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeviceType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeviceType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeviceTypeMultiError, or
// nil if none found.
func (m *DeviceType) ValidateAll() error {
	return m.validate(true)
}

func (m *DeviceType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetModel()); l < 1 || l > 100 {
		err := DeviceTypeValidationError{
			field:  "Model",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := DeviceTypeValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeviceType_Slug_Pattern.MatchString(m.GetSlug()) {
		err := DeviceTypeValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetManufacturer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeviceTypeValidationError{
					field:  "Manufacturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeviceTypeValidationError{
					field:  "Manufacturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManufacturer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeviceTypeValidationError{
				field:  "Manufacturer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceTypeValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceTypeValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceTypeValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := DeviceTypeValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if m.PartNumber != nil {

		if utf8.RuneCountInString(m.GetPartNumber()) > 50 {
			err := DeviceTypeValidationError{
				field:  "PartNumber",
				reason: "value length must be at most 50 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return DeviceTypeMultiError(errors)
	}

	return nil
}

// DeviceTypeMultiError is an error wrapping multiple validation errors
// returned by DeviceType.ValidateAll() if the designated constraints aren't met.
type DeviceTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceTypeMultiError) AllErrors() []error { return m }

// DeviceTypeValidationError is the validation error returned by
// DeviceType.Validate if the designated constraints aren't met.
type DeviceTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceTypeValidationError) ErrorName() string { return "DeviceTypeValidationError" }

// Error satisfies the builtin error interface
func (e DeviceTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeviceType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceTypeValidationError{}

var _DeviceType_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

// Validate checks the field values on Manufacturer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Manufacturer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Manufacturer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ManufacturerMultiError, or
// nil if none found.
func (m *Manufacturer) ValidateAll() error {
	return m.validate(true)
}

func (m *Manufacturer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := ManufacturerValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := ManufacturerValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Manufacturer_Slug_Pattern.MatchString(m.GetSlug()) {
		err := ManufacturerValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManufacturerValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManufacturerValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManufacturerValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := ManufacturerValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ManufacturerMultiError(errors)
	}

	return nil
}

// ManufacturerMultiError is an error wrapping multiple validation errors
// returned by Manufacturer.ValidateAll() if the designated constraints aren't met.
type ManufacturerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManufacturerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManufacturerMultiError) AllErrors() []error { return m }

// ManufacturerValidationError is the validation error returned by
// Manufacturer.Validate if the designated constraints aren't met.
type ManufacturerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManufacturerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManufacturerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManufacturerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManufacturerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManufacturerValidationError) ErrorName() string { return "ManufacturerValidationError" }

// Error satisfies the builtin error interface
func (e ManufacturerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManufacturer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManufacturerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManufacturerValidationError{}

var _Manufacturer_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

// Validate checks the field values on Platform with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Platform) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Platform with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlatformMultiError, or nil
// if none found.
func (m *Platform) ValidateAll() error {
	return m.validate(true)
}

func (m *Platform) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := PlatformValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := PlatformValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Platform_Slug_Pattern.MatchString(m.GetSlug()) {
		err := PlatformValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetManufacturer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlatformValidationError{
					field:  "Manufacturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlatformValidationError{
					field:  "Manufacturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManufacturer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlatformValidationError{
				field:  "Manufacturer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PlatformValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PlatformValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PlatformValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := PlatformValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return PlatformMultiError(errors)
	}

	return nil
}

// PlatformMultiError is an error wrapping multiple validation errors returned
// by Platform.ValidateAll() if the designated constraints aren't met.
type PlatformMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlatformMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlatformMultiError) AllErrors() []error { return m }

// PlatformValidationError is the validation error returned by
// Platform.Validate if the designated constraints aren't met.
type PlatformValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlatformValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlatformValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlatformValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlatformValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlatformValidationError) ErrorName() string { return "PlatformValidationError" }

// Error satisfies the builtin error interface
func (e PlatformValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlatform.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlatformValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlatformValidationError{}

var _Platform_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

// Validate checks the field values on Prefix with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Prefix) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Prefix with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PrefixMultiError, or nil if none found.
func (m *Prefix) ValidateAll() error {
	return m.validate(true)
}

func (m *Prefix) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetPrefix()); ip == nil {
		err := PrefixValidationError{
			field:  "Prefix",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSite()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrefixValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrefixValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSite()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrefixValidationError{
				field:  "Site",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _Prefix_Status_InLookup[m.GetStatus()]; !ok {
		err := PrefixValidationError{
			field:  "Status",
			reason: "value must be in list [active container reserved deprecated]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrefixValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrefixValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrefixValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.IsPool != nil {
		// no validation rules for IsPool
	}

	if m.MarkUtilized != nil {
		// no validation rules for MarkUtilized
	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := PrefixValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if len(errors) > 0 {
		return PrefixMultiError(errors)
	}

	return nil
}

// PrefixMultiError is an error wrapping multiple validation errors returned by
// Prefix.ValidateAll() if the designated constraints aren't met.
type PrefixMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrefixMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrefixMultiError) AllErrors() []error { return m }

// PrefixValidationError is the validation error returned by Prefix.Validate if
// the designated constraints aren't met.
type PrefixValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrefixValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrefixValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrefixValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrefixValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrefixValidationError) ErrorName() string { return "PrefixValidationError" }

// Error satisfies the builtin error interface
func (e PrefixValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrefix.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrefixValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrefixValidationError{}

var _Prefix_Status_InLookup = map[string]struct{}{
	"active":     {},
	"container":  {},
	"reserved":   {},
	"deprecated": {},
}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := RoleValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := RoleValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Role_Slug_Pattern.MatchString(m.GetSlug()) {
		err := RoleValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColor()) != 6 {
		err := RoleValidationError{
			field:  "Color",
			reason: "value length must be 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_Role_Color_Pattern.MatchString(m.GetColor()) {
		err := RoleValidationError{
			field:  "Color",
			reason: "value does not match regex pattern \"^[0-9a-f]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := RoleValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

var _Role_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

var _Role_Color_Pattern = regexp.MustCompile("^[0-9a-f]{6}$")

// Validate checks the field values on Site with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Site) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Site with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SiteMultiError, or nil if none found.
func (m *Site) ValidateAll() error {
	return m.validate(true)
}

func (m *Site) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := SiteValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := SiteValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Site_Slug_Pattern.MatchString(m.GetSlug()) {
		err := SiteValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Site_Status_InLookup[m.GetStatus()]; !ok {
		err := SiteValidationError{
			field:  "Status",
			reason: "value must be in list [planned staging active decommissioning retired]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SiteValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SiteValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SiteValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Facility != nil {

		if utf8.RuneCountInString(m.GetFacility()) > 50 {
			err := SiteValidationError{
				field:  "Facility",
				reason: "value length must be at most 50 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.TimeZone != nil {
		// no validation rules for TimeZone
	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 200 {
			err := SiteValidationError{
				field:  "Description",
				reason: "value length must be at most 200 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Comments != nil {
		// no validation rules for Comments
	}

	if len(errors) > 0 {
		return SiteMultiError(errors)
	}

	return nil
}

// SiteMultiError is an error wrapping multiple validation errors returned by
// Site.ValidateAll() if the designated constraints aren't met.
type SiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SiteMultiError) AllErrors() []error { return m }

// SiteValidationError is the validation error returned by Site.Validate if the
// designated constraints aren't met.
type SiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SiteValidationError) ErrorName() string { return "SiteValidationError" }

// Error satisfies the builtin error interface
func (e SiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SiteValidationError{}

var _Site_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

var _Site_Status_InLookup = map[string]struct{}{
	"planned":         {},
	"staging":         {},
	"active":          {},
	"decommissioning": {},
	"retired":         {},
}

// Validate checks the field values on Tag with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagMultiError, or nil if none found.
func (m *Tag) ValidateAll() error {
	return m.validate(true)
}

func (m *Tag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 100 {
		err := TagValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSlug()); l < 1 || l > 100 {
		err := TagValidationError{
			field:  "Slug",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tag_Slug_Pattern.MatchString(m.GetSlug()) {
		err := TagValidationError{
			field:  "Slug",
			reason: "value does not match regex pattern \"^[-a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColor()) != 6 {
		err := TagValidationError{
			field:  "Color",
			reason: "value length must be 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if !_Tag_Color_Pattern.MatchString(m.GetColor()) {
		err := TagValidationError{
			field:  "Color",
			reason: "value does not match regex pattern \"^[0-9a-f]{6}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TagMultiError(errors)
	}

	return nil
}

// TagMultiError is an error wrapping multiple validation errors returned by
// Tag.ValidateAll() if the designated constraints aren't met.
type TagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagMultiError) AllErrors() []error { return m }

// TagValidationError is the validation error returned by Tag.Validate if the
// designated constraints aren't met.
type TagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagValidationError) ErrorName() string { return "TagValidationError" }

// Error satisfies the builtin error interface
func (e TagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagValidationError{}

var _Tag_Slug_Pattern = regexp.MustCompile("^[-a-zA-Z0-9_]+$")

var _Tag_Color_Pattern = regexp.MustCompile("^[0-9a-f]{6}$")

// Validate checks the field values on Entity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Entity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Entity with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EntityMultiError, or nil if none found.
func (m *Entity) ValidateAll() error {
	return m.validate(true)
}

func (m *Entity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTimestamp() == nil {
		err := EntityValidationError{
			field:  "Timestamp",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if t := m.GetTimestamp(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = EntityValidationError{
				field:  "Timestamp",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) >= 0 {
				err := EntityValidationError{
					field:  "Timestamp",
					reason: "value must be less than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	switch v := m.Entity.(type) {
	case *Entity_Site:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Site",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Site",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Site",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Platform:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPlatform()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Platform",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Platform",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPlatform()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Manufacturer:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetManufacturer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Manufacturer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Manufacturer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetManufacturer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Manufacturer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Device:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDevice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Device",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Device",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDevice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Device",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_DeviceRole:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeviceRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "DeviceRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "DeviceRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeviceRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "DeviceRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_DeviceType:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeviceType()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "DeviceType",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "DeviceType",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeviceType()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "DeviceType",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Interface:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInterface()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Interface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Interface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInterface()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Interface",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_IpAddress:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIpAddress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "IpAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "IpAddress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIpAddress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "IpAddress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Prefix:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrefix()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Prefix",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Prefix",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrefix()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Prefix",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_ClusterGroup:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetClusterGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "ClusterGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "ClusterGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClusterGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "ClusterGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_ClusterType:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetClusterType()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "ClusterType",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "ClusterType",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClusterType()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "ClusterType",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_Cluster:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCluster()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Cluster",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "Cluster",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Entity_VirtualMachine:
		if v == nil {
			err := EntityValidationError{
				field:  "Entity",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVirtualMachine()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityValidationError{
						field:  "VirtualMachine",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualMachine()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityValidationError{
					field:  "VirtualMachine",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EntityMultiError(errors)
	}

	return nil
}

// EntityMultiError is an error wrapping multiple validation errors returned by
// Entity.ValidateAll() if the designated constraints aren't met.
type EntityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMultiError) AllErrors() []error { return m }

// EntityValidationError is the validation error returned by Entity.Validate if
// the designated constraints aren't met.
type EntityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityValidationError) ErrorName() string { return "EntityValidationError" }

// Error satisfies the builtin error interface
func (e EntityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityValidationError{}

// Validate checks the field values on IngestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IngestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IngestRequestMultiError, or
// nil if none found.
func (m *IngestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetStream()); l < 1 || l > 255 {
		err := IngestRequestValidationError{
			field:  "Stream",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetEntities()); l < 1 || l > 1000 {
		err := IngestRequestValidationError{
			field:  "Entities",
			reason: "value must contain between 1 and 1000 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngestRequestValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngestRequestValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngestRequestValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if err := m._validateUuid(m.GetId()); err != nil {
		err = IngestRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProducerAppName()); l < 1 || l > 255 {
		err := IngestRequestValidationError{
			field:  "ProducerAppName",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetProducerAppVersion()); l < 1 || l > 255 {
		err := IngestRequestValidationError{
			field:  "ProducerAppVersion",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSdkName()); l < 1 || l > 255 {
		err := IngestRequestValidationError{
			field:  "SdkName",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IngestRequest_SdkVersion_Pattern.MatchString(m.GetSdkVersion()) {
		err := IngestRequestValidationError{
			field:  "SdkVersion",
			reason: "value does not match regex pattern \"^(\\\\d)+\\\\.(\\\\d)+\\\\.(\\\\d)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IngestRequestMultiError(errors)
	}

	return nil
}

func (m *IngestRequest) _validateUuid(uuid string) error {
	if matched := _ingester_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// IngestRequestMultiError is an error wrapping multiple validation errors
// returned by IngestRequest.ValidateAll() if the designated constraints
// aren't met.
type IngestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestRequestMultiError) AllErrors() []error { return m }

// IngestRequestValidationError is the validation error returned by
// IngestRequest.Validate if the designated constraints aren't met.
type IngestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestRequestValidationError) ErrorName() string { return "IngestRequestValidationError" }

// Error satisfies the builtin error interface
func (e IngestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestRequestValidationError{}

var _IngestRequest_SdkVersion_Pattern = regexp.MustCompile("^(\\d)+\\.(\\d)+\\.(\\d)+$")

// Validate checks the field values on IngestResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IngestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IngestResponseMultiError,
// or nil if none found.
func (m *IngestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IngestResponseMultiError(errors)
	}

	return nil
}

// IngestResponseMultiError is an error wrapping multiple validation errors
// returned by IngestResponse.ValidateAll() if the designated constraints
// aren't met.
type IngestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestResponseMultiError) AllErrors() []error { return m }

// IngestResponseValidationError is the validation error returned by
// IngestResponse.Validate if the designated constraints aren't met.
type IngestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestResponseValidationError) ErrorName() string { return "IngestResponseValidationError" }

// Error satisfies the builtin error interface
func (e IngestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestResponseValidationError{}
